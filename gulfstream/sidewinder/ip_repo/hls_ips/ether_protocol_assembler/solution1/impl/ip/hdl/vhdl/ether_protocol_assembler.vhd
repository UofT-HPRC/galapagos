-- ==============================================================
-- RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2019.1
-- Copyright (C) 1986-2019 Xilinx, Inc. All Rights Reserved.
-- 
-- ===========================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity ether_protocol_assembler is
port (
    ap_clk : IN STD_LOGIC;
    ap_rst : IN STD_LOGIC;
    eth_arp_in_data_V : IN STD_LOGIC_VECTOR (511 downto 0);
    eth_arp_in_keep_V : IN STD_LOGIC_VECTOR (63 downto 0);
    eth_arp_in_valid_V : IN STD_LOGIC_VECTOR (0 downto 0);
    eth_arp_in_last_V : IN STD_LOGIC_VECTOR (0 downto 0);
    arp_ready_V : OUT STD_LOGIC_VECTOR (0 downto 0);
    eth_ip_in_data_V : IN STD_LOGIC_VECTOR (511 downto 0);
    eth_ip_in_keep_V : IN STD_LOGIC_VECTOR (63 downto 0);
    eth_ip_in_valid_V : IN STD_LOGIC_VECTOR (0 downto 0);
    eth_ip_in_last_V : IN STD_LOGIC_VECTOR (0 downto 0);
    ip_ready_V : OUT STD_LOGIC_VECTOR (0 downto 0);
    eth_out_data_V : OUT STD_LOGIC_VECTOR (511 downto 0);
    eth_out_keep_V : OUT STD_LOGIC_VECTOR (63 downto 0);
    eth_out_valid_V : OUT STD_LOGIC_VECTOR (0 downto 0);
    eth_out_last_V : OUT STD_LOGIC_VECTOR (0 downto 0);
    eth_out_ready_V : IN STD_LOGIC_VECTOR (0 downto 0) );
end;


architecture behav of ether_protocol_assembler is 
    attribute CORE_GENERATION_INFO : STRING;
    attribute CORE_GENERATION_INFO of behav : architecture is
    "ether_protocol_assembler,hls_ip_2019_1,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=1,HLS_INPUT_PART=xczu19eg-ffvc1760-2-i,HLS_INPUT_CLOCK=3.103000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=1.575750,HLS_SYN_LAT=0,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=581,HLS_SYN_LUT=1196,HLS_VERSION=2019_1}";
    constant ap_const_logic_1 : STD_LOGIC := '1';
    constant ap_ST_fsm_state1 : STD_LOGIC_VECTOR (0 downto 0) := "1";
    constant ap_const_lv512_lc_1 : STD_LOGIC_VECTOR (511 downto 0) := "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    constant ap_const_lv64_0 : STD_LOGIC_VECTOR (63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
    constant ap_const_lv1_0 : STD_LOGIC_VECTOR (0 downto 0) := "0";
    constant ap_const_lv1_1 : STD_LOGIC_VECTOR (0 downto 0) := "1";
    constant ap_const_lv32_0 : STD_LOGIC_VECTOR (31 downto 0) := "00000000000000000000000000000000";
    constant ap_const_logic_0 : STD_LOGIC := '0';
    constant ap_const_boolean_1 : BOOLEAN := true;

    signal eth_out_reg_data_V : STD_LOGIC_VECTOR (511 downto 0) := "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    signal eth_out_reg_keep_V : STD_LOGIC_VECTOR (63 downto 0) := "0000000000000000000000000000000000000000000000000000000000000000";
    signal eth_out_reg_valid_V : STD_LOGIC_VECTOR (0 downto 0) := "0";
    signal eth_out_reg_last_V : STD_LOGIC_VECTOR (0 downto 0) := "0";
    signal arbiter_V : STD_LOGIC_VECTOR (0 downto 0) := "1";
    signal output_sw_reg_V : STD_LOGIC_VECTOR (0 downto 0) := "0";
    signal ap_phi_mux_lhs_V_3_phi_fu_177_p8 : STD_LOGIC_VECTOR (0 downto 0);
    signal ap_CS_fsm : STD_LOGIC_VECTOR (0 downto 0) := "1";
    attribute fsm_encoding : string;
    attribute fsm_encoding of ap_CS_fsm : signal is "none";
    signal ap_CS_fsm_state1 : STD_LOGIC;
    attribute fsm_encoding of ap_CS_fsm_state1 : signal is "none";
    signal ret_V_fu_253_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal and_ln69_fu_265_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal or_ln73_fu_277_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal eth_ip_in_data_V_eth_fu_313_p3 : STD_LOGIC_VECTOR (511 downto 0);
    signal eth_out_ready_V_read_read_fu_78_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal eth_ip_in_keep_V_eth_fu_321_p3 : STD_LOGIC_VECTOR (63 downto 0);
    signal eth_ip_in_valid_V_et_fu_329_p3 : STD_LOGIC_VECTOR (0 downto 0);
    signal eth_ip_in_last_V_eth_fu_337_p3 : STD_LOGIC_VECTOR (0 downto 0);
    signal xor_ln80_fu_295_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal ret_V_5_fu_243_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal xor_ln73_fu_271_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal ret_V_2_fu_289_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal lhs_V_2_fu_369_p2 : STD_LOGIC_VECTOR (0 downto 0);
    signal ap_NS_fsm : STD_LOGIC_VECTOR (0 downto 0);


begin




    ap_CS_fsm_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                ap_CS_fsm <= ap_ST_fsm_state1;
            else
                ap_CS_fsm <= ap_NS_fsm;
            end if;
        end if;
    end process;


    arbiter_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                arbiter_V <= ap_const_lv1_1;
            else
                if (((or_ln73_fu_277_p2 = ap_const_lv1_1) and (ret_V_fu_253_p2 = ap_const_lv1_1) and (ap_const_lv1_0 = and_ln69_fu_265_p2) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
                    arbiter_V <= xor_ln80_fu_295_p2;
                elsif ((((ret_V_fu_253_p2 = ap_const_lv1_1) and (or_ln73_fu_277_p2 = ap_const_lv1_0) and (ap_const_lv1_0 = and_ln69_fu_265_p2) and (ap_const_logic_1 = ap_CS_fsm_state1)) or ((ap_const_lv1_1 = and_ln69_fu_265_p2) and (ret_V_fu_253_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1)))) then 
                    arbiter_V <= ap_const_lv1_0;
                end if; 
            end if;
        end if;
    end process;


    eth_out_reg_data_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                eth_out_reg_data_V <= ap_const_lv512_lc_1;
            else
                if (((eth_out_ready_V_read_read_fu_78_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
                    eth_out_reg_data_V <= eth_ip_in_data_V_eth_fu_313_p3;
                end if; 
            end if;
        end if;
    end process;


    eth_out_reg_keep_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                eth_out_reg_keep_V <= ap_const_lv64_0;
            else
                if (((eth_out_ready_V_read_read_fu_78_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
                    eth_out_reg_keep_V <= eth_ip_in_keep_V_eth_fu_321_p3;
                end if; 
            end if;
        end if;
    end process;


    eth_out_reg_last_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                eth_out_reg_last_V <= ap_const_lv1_0;
            else
                if (((eth_out_ready_V_read_read_fu_78_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
                    eth_out_reg_last_V <= eth_ip_in_last_V_eth_fu_337_p3;
                end if; 
            end if;
        end if;
    end process;


    eth_out_reg_valid_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                eth_out_reg_valid_V <= ap_const_lv1_0;
            else
                if (((eth_out_ready_V_read_read_fu_78_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
                    eth_out_reg_valid_V <= eth_ip_in_valid_V_et_fu_329_p3;
                end if; 
            end if;
        end if;
    end process;


    output_sw_reg_V_assign_proc : process(ap_clk)
    begin
        if (ap_clk'event and ap_clk =  '1') then
            if (ap_rst = '1') then
                output_sw_reg_V <= ap_const_lv1_0;
            else
                if (((ret_V_fu_253_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then
                    if ((ap_const_lv1_1 = and_ln69_fu_265_p2)) then 
                        output_sw_reg_V <= ap_const_lv1_0;
                    elsif (((or_ln73_fu_277_p2 = ap_const_lv1_0) and (ap_const_lv1_0 = and_ln69_fu_265_p2))) then 
                        output_sw_reg_V <= ap_const_lv1_1;
                    end if;
                end if; 
            end if;
        end if;
    end process;


    ap_NS_fsm_assign_proc : process (ap_CS_fsm)
    begin
        case ap_CS_fsm is
            when ap_ST_fsm_state1 => 
                ap_NS_fsm <= ap_ST_fsm_state1;
            when others =>  
                ap_NS_fsm <= "X";
        end case;
    end process;
    and_ln69_fu_265_p2 <= (output_sw_reg_V and eth_arp_in_valid_V);
    ap_CS_fsm_state1 <= ap_CS_fsm(0);

    ap_phi_mux_lhs_V_3_phi_fu_177_p8_assign_proc : process(output_sw_reg_V, ap_CS_fsm_state1, ret_V_fu_253_p2, and_ln69_fu_265_p2, or_ln73_fu_277_p2)
    begin
        if ((((ret_V_fu_253_p2 = ap_const_lv1_0) and (ap_const_logic_1 = ap_CS_fsm_state1)) or ((or_ln73_fu_277_p2 = ap_const_lv1_1) and (ret_V_fu_253_p2 = ap_const_lv1_1) and (ap_const_lv1_0 = and_ln69_fu_265_p2) and (ap_const_logic_1 = ap_CS_fsm_state1)))) then 
            ap_phi_mux_lhs_V_3_phi_fu_177_p8 <= output_sw_reg_V;
        elsif (((ret_V_fu_253_p2 = ap_const_lv1_1) and (or_ln73_fu_277_p2 = ap_const_lv1_0) and (ap_const_lv1_0 = and_ln69_fu_265_p2) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
            ap_phi_mux_lhs_V_3_phi_fu_177_p8 <= ap_const_lv1_1;
        elsif (((ap_const_lv1_1 = and_ln69_fu_265_p2) and (ret_V_fu_253_p2 = ap_const_lv1_1) and (ap_const_logic_1 = ap_CS_fsm_state1))) then 
            ap_phi_mux_lhs_V_3_phi_fu_177_p8 <= ap_const_lv1_0;
        else 
            ap_phi_mux_lhs_V_3_phi_fu_177_p8 <= "X";
        end if; 
    end process;

    arp_ready_V <= (lhs_V_2_fu_369_p2 and eth_out_ready_V);
    eth_ip_in_data_V_eth_fu_313_p3 <= 
        eth_ip_in_data_V when (ap_phi_mux_lhs_V_3_phi_fu_177_p8(0) = '1') else 
        eth_arp_in_data_V;
    eth_ip_in_keep_V_eth_fu_321_p3 <= 
        eth_ip_in_keep_V when (ap_phi_mux_lhs_V_3_phi_fu_177_p8(0) = '1') else 
        eth_arp_in_keep_V;
    eth_ip_in_last_V_eth_fu_337_p3 <= 
        eth_ip_in_last_V when (ap_phi_mux_lhs_V_3_phi_fu_177_p8(0) = '1') else 
        eth_arp_in_last_V;
    eth_ip_in_valid_V_et_fu_329_p3 <= 
        eth_ip_in_valid_V when (ap_phi_mux_lhs_V_3_phi_fu_177_p8(0) = '1') else 
        eth_arp_in_valid_V;
    eth_out_data_V <= 
        eth_out_reg_data_V when (eth_out_ready_V(0) = '1') else 
        ap_const_lv512_lc_1;
    eth_out_keep_V <= 
        eth_out_reg_keep_V when (eth_out_ready_V(0) = '1') else 
        ap_const_lv64_0;
    eth_out_last_V <= (eth_out_reg_last_V and eth_out_ready_V);
    eth_out_ready_V_read_read_fu_78_p2 <= eth_out_ready_V;
    eth_out_valid_V <= (eth_out_reg_valid_V and eth_out_ready_V);
    ip_ready_V <= (eth_out_ready_V and ap_phi_mux_lhs_V_3_phi_fu_177_p8);
    lhs_V_2_fu_369_p2 <= (ap_phi_mux_lhs_V_3_phi_fu_177_p8 xor ap_const_lv1_1);
    or_ln73_fu_277_p2 <= (xor_ln73_fu_271_p2 or output_sw_reg_V);
    ret_V_2_fu_289_p2 <= (eth_ip_in_valid_V or eth_arp_in_valid_V);
    ret_V_5_fu_243_p2 <= (eth_out_reg_valid_V and eth_out_reg_last_V);
    ret_V_fu_253_p2 <= (ret_V_5_fu_243_p2 or arbiter_V);
    xor_ln73_fu_271_p2 <= (eth_ip_in_valid_V xor ap_const_lv1_1);
    xor_ln80_fu_295_p2 <= (ret_V_2_fu_289_p2 xor ap_const_lv1_1);
end behav;
